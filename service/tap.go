package service

import (
	"fmt"
	"log"
	// "net" // Removed unused import

	"github.com/igor04091968/sing-chisel-tel/database"
	"github.com/igor04091968/sing-chisel-tel/database/model"
	"github.com/songgao/water"
	"github.com/vishvananda/netlink"
	"gorm.io/gorm"
)

// TapService handles the business logic for TAP tunnels.
// NOTE: All methods that manipulate network interfaces (assigning IP, bringing up/down)
// require root privileges to run. Creating the TAP device itself might not,
// depending on /dev/net/tun permissions, but full configuration does.
type TapService struct {
	db *gorm.DB
}

// NewTapService creates a new instance of TapService.
func NewTapService() *TapService {
	return &TapService{
		db: database.GetDB(),
	}
}

// CreateTapTunnel creates a new TAP interface and saves its config to the DB.
// This operation requires root privileges for full configuration.
func (s *TapService) CreateTapTunnel(config *model.TapTunnel) error {
	// 1. Create the TAP device using water library
	waterConfig := water.Config{
		DeviceType: water.TAP,
		// Name: config.Name, // water library might not respect this name directly, it generates one
	}
	ifce, err := water.New(waterConfig)
	if err != nil {
		return fmt.Errorf("failed to create TAP device: %w", err)
	}
	// Update config name with the actual name generated by water
	config.Name = ifce.Name()

	// 2. Get the netlink link for the created device
	link, err := netlink.LinkByName(config.Name)
	if err != nil {
		_ = ifce.Close() // Rollback water device
		return fmt.Errorf("failed to get netlink link for TAP device '%s': %w", config.Name, err)
	}

	// 3. Set MTU
	if config.MTU > 0 {
		if err := netlink.LinkSetMTU(link, config.MTU); err != nil {
			_ = netlink.LinkDel(link) // Rollback netlink device
			_ = ifce.Close()          // Rollback water device
			return fmt.Errorf("failed to set MTU for TAP device '%s': %w", config.Name, err)
		}
	}

	// 4. Parse and add IP address
	addr, err := netlink.ParseAddr(config.LocalAddress)
	if err != nil {
		_ = netlink.LinkDel(link) // Rollback netlink device
		_ = ifce.Close()          // Rollback water device
		return fmt.Errorf("invalid local address '%s' for TAP device: %w", config.LocalAddress, err)
	}
	if err := netlink.AddrAdd(link, addr); err != nil {
		_ = netlink.LinkDel(link) // Rollback netlink device
		_ = ifce.Close()          // Rollback water device
		return fmt.Errorf("failed to add IP address to TAP device '%s': %w", config.Name, err)
	}

	// 5. Bring the interface up
	if err := netlink.LinkSetUp(link); err != nil {
		_ = netlink.LinkDel(link) // Rollback netlink device
		_ = ifce.Close()          // Rollback water device
		return fmt.Errorf("failed to bring up TAP device '%s': %w", config.Name, err)
	}

	// Save to database
	config.Status = "up"
	if err := s.db.Create(config).Error; err != nil {
		_ = s.DeleteTapTunnel(config.ID) // Rollback from DB and network
		_ = ifce.Close()                 // Ensure water device is closed
		return fmt.Errorf("failed to save TAP tunnel config to database: %w", err)
	}

	// NOTE: The 'ifce' (water.Interface) needs to be kept open for the TAP device to persist
	// and for data to be read/written. For a simple API, we create it and assume
	// an external process or future logic will handle the data plane.
	// For now, we just log that it's created.
	log.Printf("TAP device '%s' created and configured with IP %s", config.Name, config.LocalAddress)

	return nil
}

// DeleteTapTunnel deletes a TAP interface and removes its config from the DB.
// This operation requires root privileges.
func (s *TapService) DeleteTapTunnel(id uint) error {
	// First, find the config in the DB
	config, err := s.GetTapTunnel(id)
	if err != nil {
		return fmt.Errorf("failed to find TAP tunnel with ID %d: %w", id, err)
	}

	// Find the link by name
	link, err := netlink.LinkByName(config.Name)
	if err != nil {
		// If link doesn't exist, we can still proceed to delete from DB
		// but we should log it.
		fmt.Printf("Warning: could not find link '%s' to delete, but proceeding with DB record removal. Error: %v\n", config.Name, err)
	} else {
		// If link exists, delete it
		if err := netlink.LinkDel(link); err != nil {
			return fmt.Errorf("failed to delete TAP interface '%s': %w", config.Name, err)
		}
	}

	// Delete from database
	if err := s.db.Delete(&model.TapTunnel{}, id).Error; err != nil {
		return fmt.Errorf("failed to delete TAP tunnel config from database: %w", err)
	}

	return nil
}

// GetTapTunnelByName retrieves a single TAP tunnel configuration by its name.
func (s *TapService) GetTapTunnelByName(name string) (*model.TapTunnel, error) {
	var config model.TapTunnel
	err := s.db.Where("name = ?", name).First(&config).Error
	return &config, err
}

// GetAllTapTunnels retrieves all TAP tunnel configurations from the database.
func (s *TapService) GetAllTapTunnels() ([]model.TapTunnel, error) {
	var configs []model.TapTunnel
	err := s.db.Find(&configs).Error
	return configs, err
}

// GetTapTunnel retrieves a single TAP tunnel configuration by its ID.
func (s *TapService) GetTapTunnel(id uint) (*model.TapTunnel, error) {
	var config model.TapTunnel
	err := s.db.First(&config, id).Error
	return &config, err
}
